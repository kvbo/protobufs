// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.2
// source: charges.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	FeeManager_CreateFee_FullMethodName = "/FeeManager/CreateFee"
	FeeManager_UpdateFee_FullMethodName = "/FeeManager/UpdateFee"
	FeeManager_GetFee_FullMethodName    = "/FeeManager/GetFee"
	FeeManager_GetFees_FullMethodName   = "/FeeManager/GetFees"
	FeeManager_DeleteFee_FullMethodName = "/FeeManager/DeleteFee"
)

// FeeManagerClient is the client API for FeeManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FeeManagerClient interface {
	CreateFee(ctx context.Context, in *Fee, opts ...grpc.CallOption) (*Fee, error)
	UpdateFee(ctx context.Context, in *FeeList, opts ...grpc.CallOption) (*FeeList, error)
	GetFee(ctx context.Context, in *Fee, opts ...grpc.CallOption) (*Fee, error)
	GetFees(ctx context.Context, in *FeeList, opts ...grpc.CallOption) (*FeeList, error)
	DeleteFee(ctx context.Context, in *FeeQuery, opts ...grpc.CallOption) (*FeeList, error)
}

type feeManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewFeeManagerClient(cc grpc.ClientConnInterface) FeeManagerClient {
	return &feeManagerClient{cc}
}

func (c *feeManagerClient) CreateFee(ctx context.Context, in *Fee, opts ...grpc.CallOption) (*Fee, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Fee)
	err := c.cc.Invoke(ctx, FeeManager_CreateFee_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feeManagerClient) UpdateFee(ctx context.Context, in *FeeList, opts ...grpc.CallOption) (*FeeList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeeList)
	err := c.cc.Invoke(ctx, FeeManager_UpdateFee_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feeManagerClient) GetFee(ctx context.Context, in *Fee, opts ...grpc.CallOption) (*Fee, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Fee)
	err := c.cc.Invoke(ctx, FeeManager_GetFee_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feeManagerClient) GetFees(ctx context.Context, in *FeeList, opts ...grpc.CallOption) (*FeeList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeeList)
	err := c.cc.Invoke(ctx, FeeManager_GetFees_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feeManagerClient) DeleteFee(ctx context.Context, in *FeeQuery, opts ...grpc.CallOption) (*FeeList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeeList)
	err := c.cc.Invoke(ctx, FeeManager_DeleteFee_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FeeManagerServer is the server API for FeeManager service.
// All implementations must embed UnimplementedFeeManagerServer
// for forward compatibility.
type FeeManagerServer interface {
	CreateFee(context.Context, *Fee) (*Fee, error)
	UpdateFee(context.Context, *FeeList) (*FeeList, error)
	GetFee(context.Context, *Fee) (*Fee, error)
	GetFees(context.Context, *FeeList) (*FeeList, error)
	DeleteFee(context.Context, *FeeQuery) (*FeeList, error)
	mustEmbedUnimplementedFeeManagerServer()
}

// UnimplementedFeeManagerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFeeManagerServer struct{}

func (UnimplementedFeeManagerServer) CreateFee(context.Context, *Fee) (*Fee, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFee not implemented")
}
func (UnimplementedFeeManagerServer) UpdateFee(context.Context, *FeeList) (*FeeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFee not implemented")
}
func (UnimplementedFeeManagerServer) GetFee(context.Context, *Fee) (*Fee, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFee not implemented")
}
func (UnimplementedFeeManagerServer) GetFees(context.Context, *FeeList) (*FeeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFees not implemented")
}
func (UnimplementedFeeManagerServer) DeleteFee(context.Context, *FeeQuery) (*FeeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFee not implemented")
}
func (UnimplementedFeeManagerServer) mustEmbedUnimplementedFeeManagerServer() {}
func (UnimplementedFeeManagerServer) testEmbeddedByValue()                    {}

// UnsafeFeeManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FeeManagerServer will
// result in compilation errors.
type UnsafeFeeManagerServer interface {
	mustEmbedUnimplementedFeeManagerServer()
}

func RegisterFeeManagerServer(s grpc.ServiceRegistrar, srv FeeManagerServer) {
	// If the following call pancis, it indicates UnimplementedFeeManagerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FeeManager_ServiceDesc, srv)
}

func _FeeManager_CreateFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Fee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeeManagerServer).CreateFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeeManager_CreateFee_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeeManagerServer).CreateFee(ctx, req.(*Fee))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeeManager_UpdateFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeeList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeeManagerServer).UpdateFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeeManager_UpdateFee_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeeManagerServer).UpdateFee(ctx, req.(*FeeList))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeeManager_GetFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Fee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeeManagerServer).GetFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeeManager_GetFee_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeeManagerServer).GetFee(ctx, req.(*Fee))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeeManager_GetFees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeeList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeeManagerServer).GetFees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeeManager_GetFees_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeeManagerServer).GetFees(ctx, req.(*FeeList))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeeManager_DeleteFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeeQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeeManagerServer).DeleteFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeeManager_DeleteFee_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeeManagerServer).DeleteFee(ctx, req.(*FeeQuery))
	}
	return interceptor(ctx, in, info, handler)
}

// FeeManager_ServiceDesc is the grpc.ServiceDesc for FeeManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FeeManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "FeeManager",
	HandlerType: (*FeeManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateFee",
			Handler:    _FeeManager_CreateFee_Handler,
		},
		{
			MethodName: "UpdateFee",
			Handler:    _FeeManager_UpdateFee_Handler,
		},
		{
			MethodName: "GetFee",
			Handler:    _FeeManager_GetFee_Handler,
		},
		{
			MethodName: "GetFees",
			Handler:    _FeeManager_GetFees_Handler,
		},
		{
			MethodName: "DeleteFee",
			Handler:    _FeeManager_DeleteFee_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "charges.proto",
}
